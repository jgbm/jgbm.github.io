<html>
<head>
<title>EECS 665 &mdash; Spring 2018 &mdash; Homework 2</title>

<style type="text/css">

.topBox {
  margin-left: 200px;
  margin-top: 40px;
  padding: 20px 45px;
  max-width: 700px;
  outline-style: solid;
  outline-width: 1px;
}

.box {
  margin-left: 200px;
  margin-top: 20px;
  padding: 10px 45px;
  max-width: 700px;
  outline-style: solid;
  outline-width: 1px;
}

@media (max-width: 800px) {

  .topBox {
     margin-left: 20px;
  }

  .box {
     margin-left: 20px;
  }
}

h1 {
  font-family: Tahoma;
  font-size: 16pt;
  font-weight: normal;
}

h2 {
  font-family: Tahoma;
  font-size: 14pt;
  font-weight: normal;
  margin-left: -20px;
}

p {
  font-family: Tahoma;
  font-size: 11pt;
}

p.paper {
  cursor: pointer;
}

p.paper:hover {
  text-decoration: underline;
}

p.abstract {
  margin-left: 20px;
}

td {
  font-family: Tahoma;
  font-size: 11pt;
  padding-right: 20px;
  vertical-align: top;
}

strong {
  text-transform: lowercase;
}

span.open {
  margin-left: -20px;
  display:inline-block;
}

span.close {
  margin-left: -20px;
  display:none;
}

li {
  font-family: Tahoma;
  font-size: 11pt;
}

a {
  color: black;
  text-decoration: underline;
}

a.invisible {
  color: black;
  text-decoration: none;
}

code, pre {
  background-color: ghostwhite;
}

code {
  padding-left: 3px;
  padding-right: 3px;
}

pre {
  margin-left: 20px;
  border: 1px solid black;
  padding: 10px;
}

table.bordered {
  border-collapse: collapse
}

table.bordered td {
  padding: 5px 10px;
  border: 1px dotted black
}

</style>

</head>

<body>

<div class="topbox">

  <h1>eecs 665: compiler construction<br>homework 2</h1>

</div>

<div class="box">

  <h2>Essentials</h2>

  <table>
    <tbody>
      <tr>
        <td><strong>Code distribution</strong></td>
        <td><a href="https://ittc.ku.edu/~garrett/eecs665s18/asgn/HW2.zip">HW2.zip</a></td>
      </tr>
      <tr>
        <td><strong>Due date</strong></td>
        <td>Monday, April 16, 11:59 PM</td>
      </tr>
    </tbody>
  </table>

  <h2>Overview</h2>

  <p>
    Your task in this homework is to write a compiler from (most of) <a href="../03
    LLVMlite.pdf">the LLVMlite language</a> to <a href="../02 X86lite.pdf">the X86lite instruction
    set</a>.  You will do this by implementing the function <code>compileFunction</code> in the
    provided <code>Compiler.hs</code> file.  In implementing this function, you should support all
    of the LLVMlite operations <b>except for <code>GetElementPtr</code></b>.  The generated X86
    should produce identical results to that produced by Clang (5.0.1) give the same
    input <code>.ll</code> files; of course, you do not have to produce the same X86.
  </p>

  <p>
    The detailed description of the problem below is based on my approach to
    implementing <code>compileFunction</code>.  It is intended to help you solve the problem;
    however, <i>you do not have to follow my approach</i>.  So long as your code produces equivalent
    X86 to Clang, you will receive full credit.
  </p>

  <p>
    <b>Your solution must produce valid X86</b>, as accepted by your system assembler, not just as
    accepted by the homework 1 simulator.  This means that you must respect x86 limitations on
    instructions, including having at most one indirect reference per instruction and shifts amounts
    being constants.
  </p>

  <h2>Submission</h2>

  <p>
    You should submit your modified <code>Compiler.hs</code> file.  Do not submit any of other
    distributed files, any test cases you may have written, &amp;c.
  </p>

  <h2>Included files</h2>

  <table class="bordered">
    <tr>
      <td><tt>Compiler.hs</tt></td>
      <td>
        The compiler for LLVMlite; your work will all go here.
      </td>
    </tr>

    <tr>
      <td><tt>LL/Language.hs</tt></td>
      <td>
        Type definitions for the LLVMlite abstract syntax.  Note that we're not yet using all of the
        available parts of the syntax&mdash;for example, we're not doing anything with external
        definitions.
      </td>
    </tr>

    <tr>
      <td><tt>LL/Lexer.hs</tt></td>
      <td>
        Lexer for LLVMlite; this file is actually autogenerated from a more high-level description,
        as we'll discuss at the end of the semester.
      </td>
    </tr>

    <tr>
      <td><tt>LL/Parser.hs</tt></td>
      <td>
        Parser for LLVMlite; autogenerated, as above.
      </td>
    </tr>

    <tr>
      <td><tt>LL/Text.hs</tt></td>
      <td>
        Support for printing LLVMlite definitions.
      </td>
    </tr>

    <tr>
      <td><tt>Main.hs</tt></td>
      <td>
        Driver code to invoke your compiler on LLVMlite source code.  <i>Also includes a number of
        functions intended to help debug your compiler,</i> so you may want to take a look at this
        file.
      </td>
    </tr>

    <tr>
      <td><tt>runtime.c</tt></td>
      <td>
        C module that calls <code>int64_t function()</code> and prints the result; link together
        with <code>.s</code> or <code>.ll</code> files providing such a function.
      </td>
    </tr>

    <tr>
      <td><tt>runtimef.c</tt></td>
      <td>
        C module that calls <code>int64_t function(int64_t)</code>, with its argument being the
        first command-line parameter; link together with <code>.s</code> or <code>.ll</code> files
        providing such a function.
      </td>
    </tr>

    <tr>
      <td><tt>samples/factrec.ll</tt></td>
      <td>
        LLVMlite program implementing a recursive factorial function; I used this to test my support
        for <code>Call</code>.
      </td>
    </tr>

    <tr>
      <td><tt>samples/inclass.ll</tt></td>
      <td>
        Sample based on our in-class data flow example.
      </td>
    </tr>

    <tr>
      <td><tt>samples/lab5.ll</tt></td>
      <td>
        The function from lab 5.
      </td>
    </tr>

    <tr>
      <td><tt>samples/simple.ll</tt></td>
      <td>
        Factorial without recursion.
      </td>
    </tr>

    <tr>
      <td><tt>Text.hs</tt></td>
      <td>
        Common bits of pretty-printing framework.
      </td>
    </tr>

    <tr>
      <td><tt>X86/Loader.hs</tt></td>
      <td rowspan="6">
        As in the homework 1 solutions.
      </td>
    </tr>

    <tr>
      <td><tt>X86/Machine.hs</tt></td>
    </tr>

    <tr>
      <td><tt>X86/SimAsm.hs</tt></td>
    </tr>

    <tr>
      <td><tt>X86/Simulator.hs</tt></td>
    </tr>

    <tr>
      <td><tt>X86/Text.hs</tt></td>
    </tr>

    <tr>
      <td><tt>X86.hs</tt></td>
    </tr>
  </table>

  <h2>Detailed notes</h2>

  <p>
    This section describes the structure of my solution, and highlights some areas of particular difficulty.
  </p>

  <p>
    <b>Code structure.</b>  I broke my compiler down into one function for each level of the AST,
    writing
    functions <code>compileBlock</code>, <code>compileInstr</code>, <code>compileTerm</code>,
    and <code>compileOperand</code>.  Of these, the majority of the complexity was
    in <code>compileFunction</code>, to do with setting up the function's frame on the call stack,
    and <code>compileInstr</code>, for obvious reasons.
  </p>

  <p>
    <b>Types and sizes.</b>  The vast majority of operations, especially if you are not doing the
    extra credit, will operate on single quad-word sized values.  The one exception is the
    implementation of <code>Alloca</code>.  To help in that case, I have included
    a <code>sizeOf</code> function that will compute the size of an LLVM type.  That function needs
    to know about any named types declared in the file, which is contained in the <code>Types</code>
    environment passed to <code>compileFunction</code>.
  </p>

  <p>
    <b>Calling convention.</b> You should follow
    the <a href="https://en.wikipedia.org/wiki/X86_calling_conventions#x86-64_calling_conventions">x86-64
    calling convention</a>; your submitted code should use the Linux version, although you may want
    to also implement an easy way to switch to the Windows version if you are using that platform.
    The x86-64 calling convention passes the first six (four on Windows) arguments in registers, and
    the remainder on the stack.  You should <i>not</i> assume that you will never have functions
    with more than six arguments.
  </p>

  <p>
    <b>Temporaries.</b> Unless you are planning to do the extra credit, you should plan to store all
    temporaries on the stack, and only use registers to execute individual instructions.  My
    approach here was to collect all the temporaries in a function before compiling it, allocate
    space for them on the stack at the start of the function, and then pass a list mapping temporary
    names to stack locations to each <code>compile<i>X</i></code> function.
  </p>

  <p>
    <b>Registers.</b> Unless you are planning to do the extra credit, you will probably actually use
    very few registers.  If you pick the registers you do use correctly, you can avoid any
    interaction with callee-save registers, and can thus ignore that part of the calling convention.
  </p>

  <p>
    <b>Comparisons and quad-words.</b> Unlike every other instruction in X86lite,
    the <code>set</code> instruction does not operate on quad words, but on the lowest byte in the
    destination.  If you are using <code>set</code>, <i>do not assume that the destination location
    is zeroed unless you have done so yourself.</i>
  </p>

  <h2>Extra credit</h2>

  <p>
    There are three opportunities for extra credit on this assignment, ranked in increasing order of
    difficulty (as I perceive it...).
  </p>

  <ul>
    <li>
      Especially if you follow the naive approach to compiling temporaries described above, your
      generated assembly will include a great deal of unnecessary memory shuffling.  Add a step to
      your <code>compileFunction</code> that eliminates some of this memory shuffling.  (More credit
      eliminating more extra moves; no credit for changes that break the generated assembly.)
    </li>

    <li>
      Implement <code>GetElementPtr</code>.
    </li>

    <li>
      Implement some better strategy for register use.
    </li>
  </ul>

</div>

</body>

</html>
