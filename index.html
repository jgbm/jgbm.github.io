<html>
<head>
<title>J. Garrett Morris</title>

<style type="text/css">

.topBox {
  margin-left: 200px;
  margin-top: 40px;
  padding: 20px 45px;
  max-width: 500px;
  outline-style: solid;
  outline-width: 1px;
}

.box {
  margin-left: 200px;
  margin-top: 20px;
  padding: 10px 45px;
  max-width: 500px;
  outline-style: solid;
  outline-width: 1px;
}

@media (max-width: 800px) {

  .topBox {
     margin-left: 20px;
  }

  .box {
     margin-left: 20px;
  }
}

h1 {
  font-family: Tahoma;
  font-size: 16pt;
  font-weight: normal;
}

h2 {
  font-family: Tahoma;
  font-size: 14pt;
  font-weight: normal;
  margin-left: -20px;
}

p {
  font-family: Tahoma;
  font-size: 11pt;
}

p.paper {
  cursor: pointer;
}

p.paper:hover {
  text-decoration: underline;
}

p.abstract {
  margin-left: 20px;
}

td {
  font-family: Tahoma;
  font-size: 11pt;
  padding-right: 20px;
  padding-bottom: 5px;
  vertical-align: top;
}

td > strong {
  text-transform: lowercase;
}


span.open {
  margin-left: -20px;
  display:inline-block;
}

span.close {
  margin-left: -20px;
  display:none;
}

li {
  font-family: Tahoma;
  font-size: 11pt;
}

a {
  color: black;
  text-decoration: underline;
}

a.invisible {
  color: black;
  text-decoration: none;
}

</style>

<script type="text/javascript">

function toggle(blck) {
  var el = document.getElementById(blck);
  var closed = document.getElementById(blck + "-closed");
  var open = document.getElementById(blck + "-open");
  if (window.getComputedStyle(el, null).display == "none") {
    el.style.display = "block";
    closed.style.display = "none";
    open.style.display = "inline-block";
  } else {
    el.style.display = "none";
    closed.style.display = "inline-block";
    open.style.display = "none";
  }
}

function toggleAll() {
  var papers = ["blame-root", "cons-tf", "mixed", "bobw", "bananas", "gvhs",
                "conflate", "variants", "propositions", "oversem", "cpgv",
                "thesis", "instances", "hackage"];
  var len = papers.length;
  for (i = 0; i < len; i++) {
    toggle(papers[i]);
  }
}

</script>

</head>

<body onload='toggleAll();'>

<div class="topBox">
  <h1>j garrett morris</h1>
  <div style="font-family:tahoma; font-size:11pt; float:right; text-align: right; position: relative; top: -35px">
    <a href="#about">about</a> | <a href="#teaching">teaching</a> | <a href="#research">publications</a> | <a href="#contact">contact</a>
  </div>
</div>

<div class="box" id="about">
  <h2>about me</h2>
  <p>
    I am an assistant professor in the <a href="http://eecs.ku.edu">Department of Electrical
    Engineering and Computer Science</a> and the <a href="http://ittc.ku.edu">Information and
    Telecommunications Technology Center</a> at the <a href="http://www.ku.edu">University of
    Kansas</a>.
  </p>

  <p>
    I am currently looking for motivated Ph.D. and Master's students interested in working in
    programming languages.  If you think that might be you,
    please get in touch.
  </p>

  <p>
    My research centers on type systems for functional programming languages; in
    particular:
  </p>
  <ul>
    <li>How type system features, like substructural and session types, strengthen type safety
      guarantees;
    <li>How class system features, like instances chains and functional dependencies, provide more
      expressive abstractions; and,
    <li>How overloading mechanisms contribute to writing simple, correct code.
  </ul>

  <p>
    Before arriving in Kansas, I was a researcher in
    the <a href="http://wcms.inf.ed.ac.uk/lfcs/">Laboratory for Foundations of Computer Science</a>
    at the <a href="http://www.ed.ac.uk/home">University of Edinburgh</a>.  I worked
    with <a href="http://homepages.inf.ed.ac.uk/wadler/">Phil Wadler</a>
    and <a href="http://homepages.inf.ed.ac.uk/slindley/">Sam Lindley</a> on
    the <a href="http://groups.inf.ed.ac.uk/abcd">ABCD</a> project, which studies the role of
    session types in safe concurrent and distributed programming, and contributed to the design and
    implementation of linear types and session types for
    the <a href="http://groups.inf.ed.ac.uk/links">Links programming language</a>.  I received my
    Ph.D. from the <a href="http://www.cs.pdx.edu">computer science department</a>
    at <a href="http://www.pdx.edu">Portland State University</a>, advised
    by <a href="http://cs.pdx.edu/~mpj">Mark P. Jones</a>.  As part of
    the <a href="http://hasp.cs.pdx.edu">High Assurance Systems Programming</a> project, I
    contributed to the design of the <a href="http://www.habit-lang.org">Habit programming
    language</a>, particularly its class system, and to the development of
    the <a href="https://github.com/habit-lang/alb">Habit compiler</a>, particularly its
    typechecking and desugaring components.
  </p>
</div>

<div class="box" id="teaching">
  <h2>teaching</h2>

  <p>
    EECS 662 (Programming languages): <a href="eecs662f17/index.html">Fall 2017</a>, Spring 2019
  </p>

  <p>
    EECS 665 (Compilers): <a href="eecs665s18/index.html">Spring 2018</a>
  </p>

  <p>
    EECS 762 (Semantics): Fall 2018
  </p>
</div>


<div class="box" id="research">
 <h2>publications</h2>

 <p onclick='toggle("blame-root")' class="paper">
   <span id="blame-root-closed" class="close">&#9655;</span>
   <span id="blame-root-open" class="open">&#9661;</span>

   Jack William, J. Garrett Morris and Philip Wadler.  "The Root Cause of Blame: Contracts for
   Intersection and Union Types". <i>Proc. ACM Prog. Lang.</i> 2, OOPSLA (October 2018).  <i>To
   appear.</i>
 </p>

 <div id="blame-root">
   <p class="abstract">
     Gradual typing has emerged as the tonic for programmers wanting a mixture of static and dynamic
     typing, hoping to achieve the best of both. Sound gradual typing is the most potent brew,
     providing static type- checking and dynamic assertions. Contracts provide a lightweight form of
     gradual typing as they do not provide static checking but can be implemented as a library,
     rather than demanding language level support.
   </p>

   <p class="abstract">
     Intersection and union types are well suited to dynamic languages: intersection encodes
     overloaded functions; union encodes uncertain data arising from branching code. We extend the
     untyped lambda calculus with contracts for monitoring higher-order intersection and union
     types, giving a uniform treatment to both.  Each operator requires a single reduction rule that
     does not depend on the constituent types, or the context of the operator, unlike existing work.
   </p>

   <p class="abstract">
     We present a new method for defining contract satisfaction based on blame behaviour. A value
     positively satisfies a type if, when monitored against that type in any context, never elicits
     positive blame. A continuation negatively satisfies a type if, when monitored against that type
     using any value, never elicits negative blame.
   </p>

   <p class="abstract">
     We supplement our definition of satisfaction with a serious of monitoring properties that
     satisfying values and continuations should have. Each type has a positive property for values
     and a negative property for continuations, ensuring that contracts reflect the types they
     represent.
   </p>
 </div>

 <p onclick='toggle("cons-tf")' class="paper">
   <span id="cons-tf-closed" class="close">&#9655;</span>
   <span id="cons-tf-open" class="open">&#9661;</span>

   J. Garrett Morris and Richard A. Eisenberg.  "Constrained Type Families".  <i>Proc. ACM
   Prog. Lang.</i> 1, ICFP, Article 42 (August 2017).
 </p>

 <div id="cons-tf">
   <p class="abstract">
     We present an approach to support partiality in type-level computation without compromising
     expressiveness or type safety. Existing frameworks for type-level computation either require
     totality or implicitly assume it. For example, type families in Haskell provide a powerful,
     modular means of defining type-level computation. However, their current design implicitly
     assumes that type families are total, introducing nonsensical types and significantly
     complicating the metatheory of type families and their extensions. We propose an alternative
     design, using qualified types to pair type-level computations with predicates that capture
     their domains. Our approach naturally captures the intuitive partiality of type families,
     simplifying their metatheory. As evidence, we present the first complete proof of consistency
     for a language with closed type families.
   </p>

   <p>
     Extended edition available in <a href="pubs/morris-icfp2017-families-extended.pdf">PDF</a>.
     The conference version is available from
     the <a href="http://dl.acm.org/citation.cfm?id=3110286">ACM DL</a>, or
     in <a href="pubs/morris-icfp2017-families-extended.pdf">PDF</a>.
   </p>
 </div>

 <p onclick='toggle("mixed")' class="paper">
   <span id="mixed-closed" class="close">&#9655;</span>
   <span id="mixed-open" class="open">&#9661;</span>

   Jack Williams, J. Garrett Morris, Philip Wadler, and Jakub Zalewski. "Mixed Messages: Measuring
   Conformance and Non-Interference in TypeScript".  <i>31st European Conference on Object-Oriented
   Programming, {ECOOP} 2017,</i> LIPIcs 74, Schloss Dagstuhl - Leibniz-Zentrum f&uuml;r Informatik,
   2017.
 </p>

 <div id="mixed">
   <p class="abstract">
     TypeScript participates in the recent trend among programming languages to support gradual
     typing. The DefinitelyTyped Repository for TypeScript supplies type definitions for over 2000
     popular JavaScript libraries. However, there is no guarantee that implementations conform to
     their corresponding declarations.
   </p>

   <p class="abstract">
     We present a practical evaluation of gradual typing for TypeScript. We have developed a tool,
     based on the polymorphic blame calculus, for monitoring JavaScript libraries and TypeScript
     clients against the TypeScript definition. We apply our tool, TypeScript TNG, to those
     libraries in the DefinitelyTyped Repository which had adequate test code to use. Of the 122
     libraries we checked, 59 had cases where either the library or its tests failed to conform to
     the declaration.
   </p>

   <p class="abstract">
     Gradual typing should satisfy non-interference. Monitoring a program should never change its
     behaviour except, to raise a type error should a value not conform to its declared
     type. However, our experience also suggests serious technical concerns with the use of the
     JavaScript proxy mechanism for enforcing contracts. Of the 122 libraries we checked, 22 had
     cases where the library or its tests violated non-interference.
   </p>

   <p>Available in <a href="pubs/williams-ecoop17-proxies.pdf">PDF</a>.</p>

 </div>

 <p onclick='toggle("bobw")' class="paper">
   <span id="bobw-closed" class="close">&#9655;</span>
   <span id="bobw-open" class="open">&#9661;</span>

   J. Garrett Morris.  "The Best of Both Worlds: Linear Functional Programming Without Compromise".
   In <i>Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming
   (ICFP 2016)</i>, Nara, Japan, 2016.
 </p>

 <div id="bobw">
   <p class="abstract">
     We present a linear functional calculus with both the safety guarantees expressible with linear
     types and the rich language of combinators and composition provided by functional programming.
     Unlike previous combinations of linear typing and functional programming, we compromise neither
     the linear side (for example, our linear values are first-class citizens of the language) nor
     the functional side (for example, we do not require duplicate definitions of compositions for
     linear and unrestricted functions).  To do so, we must generalize abstraction and application
     to encompass both linear and unrestricted functions.  We capture the typing of the generalized
     constructs with a novel use of qualified types.  Our system maintains the metatheoretic
     properties of the theory of qualified types, including principal types and decidable type
     inference.  Finally, we give a formal basis for our claims of expressiveness, by showing that
     evaluation respects linearity, and that our language is a conservative extension of existing
     functional calculi.
   </p>

   <p>
     The extended edition is available in <a href="pubs/morris-icfp2016-linearity-extended.pdf">PDF</a>.
     Note that this version fixes several inadvertent omissions and typographical errors, and so
     should be preferred to the conference version.  The conference version is available from
     the <a href="http://dl.acm.org/citation.cfm?id=2951925">ACM DL</a>.
 </div>

 <p onclick='toggle("bananas")' class="paper">
   <span id="bananas-closed" class="close">&#9655;</span>
   <span id="bananas-open" class="open">&#9661;</span>

    Sam Lindley and J. Garrett Morris.  "Talking Bananas: Structural Recursion for Session Types".
    In <i>Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming
    (ICFP 2016)</i>, Nara, Japan, 2016.
 </p>

 <div id="bananas">
   <p class="abstract">
     Session types provide static guarantees that concurrent programs respect communication
     protocols.  We give a novel account of recursive session types in the context of GV, a small
     concurrent extension of the linear &#955;-calculus.  We extend GV with recursive types and
     catamorphisms, following the initial algebra semantics of recursion, and show that doing so
     naturally gives rise to recursive session types.  We show that this principled approach to
     recursion resolves long-standing problems in the treatment of duality for recursive session
     types.
   </p>
   <p class="abstract">
     We characterize the expressiveness of GV concurrency by giving a CPS translation to
     (non-concurrent) &#955;-calculus and proving that reduction in GV is simulated by full
     reduction in &#955;-calculus. This shows that GV remains terminating in the presence of
     positive recursive types, and that such arguments extend to other extensions of GV, such as
     polymorphism or non-linear types, by appeal to normalization results for sequential
     &#955;-calculi.  We also show that GV remains deadlock free and deterministic in the presence
     of recursive types.
   </p>
   <p class="abstract">
     Finally, we extend CP, a session-typed process calculus based on linear logic, with recursive
     types, and show that doing so preserves the connection between reduction in GV and cut
     elimination in CP.
   </p>

   <p>
     Available in <a href="pubs/lindley-icfp2016-bananas.pdf">PDF</a> or from
     the <a href="http://dl.acm.org/citation.cfm?id=2951921">ACM DL</a>.
   </p>
 </div>

 <p onclick='toggle("gvhs")' class="paper">
   <span id="gvhs-closed" class="close">&#9655;</span>
   <span id="gvhs-open" class="open">&#9661;</span>

   Sam Lindley and J. Garrett Morris. "Embedding Session Types in Haskell".  In <i>Proceedings of
   the 9th International Symposium on Haskell (Haskell 2016)</i>, Nara, Japan, 2016.
 </p>

 <div id="gvhs">
   <p class="abstract">
     We present a novel embedding of session-typed concurrency in Haskell.

     We extend an existing HOAS embedding of the linear &lambda;-calculus with a set of core
     session-typed primitives, using indexed type families to express the constraints of the session
     typing discipline.

     We give two interpretations of our embedding, one in terms of GHC's built-in concurrency and
     another in terms of purely functional continuations.

     Our safety guarantees, including deadlock freedom, are assured statically and introduce no
     additional runtime overhead.
   </p>
   <p>Paper available in <a href="pubs/lindley-hs2016-gvhs.pdf">PDF</a> or from
   the <a href="http://dl.acm.org/citation.cfm?id=2976018">ACM DL</a>.  See the source code
   on <a href="http://github.com/jgbm/gvinhs">Github</a>.
   </p>
 </div>

 <p onclick='toggle("conflate")' class="paper">
   <span id="conflate-closed" class="close">&#9655;</span>
   <span id="conflate-open" class="open">&#9661;</span>
   Robert Atkey, Sam Lindley, and J. Garrett Morris. "Conflation Confers Concurrency".  In <i>A
    List of Successes That Can Change the World: Essays Dedicated to Philip Wadler on the Occasion
    of His 60th Birthday</i>. LNCS
    9600.
 </p>

 <div id="conflate">
   <p class="abstract">
     Session types provide a static guarantee that concurrent programs respect communication
     protocols.  Recent work has explored a correspondence between proof rules and cut reduction in
     linear logic and typing and evaluation of process calculi. This paper considers two approaches
     to extend logically-founded process calculi. First, we consider extensions of the process
     calculus to more closely resemble &#960;-calculus. Second, inspired by denotational models of
     process calculi, we consider conflating dual types. Most interestingly, we observe that these
     approaches coincide: conflating the multiplicatives (&#8855; and &#x214B;) allows processes to
     share multiple channels; conflating the additives (&#8853; and &) provides
     nondeterminism; and conflating the exponentials (! and ?) yields access points, a
     rendezvous mechanism for initiating session typed communication.  Access points are
     particularly expressive: for example, they are sufficient to encode concurrent state and
     general recursion.
   </p>
   <p>
     Available
     from <a href="http://link.springer.com/chapter/10.1007%2F978-3-319-30936-1_2">Springer</a> or
     in <a href="pubs/atkey-wf2016-conflate.pdf">PDF</a>.
   </p>
 </div>

 <p onclick='toggle("variants")' class="paper">
   <span id="variants-closed" class="close">&#9655;</span>
   <span id="variants-open" class="open">&#9661;</span>
   J. Garrett Morris. "Variations on Variants".  In <i>Proceedings of the 2015 ACM SIGPLAN
     Symposium on Haskell</i>, Vancouver, BC.
 </p>

 <div id="variants">
   <p class="abstract">
     Extensible variants improve the modularity and expressiveness of programming languages: they
     allow program functionality to be decomposed into independent blocks, and allow seamless
     extension of existing code with both new cases of existing data types and new operations over
     those data types.
   </p>

   <p class="abstract">
     This paper considers three approaches to providing extensible variants in Haskell.  Row typing
     is a long understood mechanism for typing extensible records and variants, but its adoption
     would require extension of Haskell's core type system.  Alternatively, we might hope to encode
     extensible variants in terms of existing mechanisms, such as type classes.  We describe an
     encoding of extensible variants using instance chains, a proposed extension of the class
     system.  Unlike many previous encodings of extensible variants, ours does not require the
     definition of a new type class for each function that consumes variants.  Finally, we translate
     our encoding to use closed type families, an existing feature of GHC.  Doing so demonstrates
     the interpretation of instances chains and functional dependencies in closed type families.
   </p>

   <p class="abstract">
     One concern with encodings like ours is how completely they match the encoded system.  We
     compare the expressiveness of our encodings with each other and with systems based on row
     types.  We find that, while equivalent terms are typable in each system, both encodings require
     explicit type annotations to resolve ambiguities in typing not present in row type systems, and
     the type family implementation retains more constraints in principal types than does the
     instance chain implementation.  We propose a general mechanism to guide the instantiation of
     ambiguous type variables, show that it eliminates the need for type annotations in our
     encodings, and discuss conditions under which it preserves coherence.
   </p>

   <p>Paper available from the <a href="http://dl.acm.org/citation.cfm?doid=2804302.2804320">ACM
   DL</a> or in <a href="pubs/morris-haskell15-variants.pdf">PDF</a>. Sample code available
   <a href="sample/Dtac.hs">here</a>.
   </p>
 </div>

 <p onclick='toggle("propositions")' class="paper">
   <span id="propositions-closed" class="close">&#9655;</span>
   <span id="propositions-open" class="open">&#9661;</span>
   Sam Lindley and J. Garrett Morris.  "A Semantics for Propositions as Sessions".  ESOP 2015.
 </p>

 <div id="propositions">
   <p class="abstract">
     Session types provide a static guarantee that concurrent programs respect communication
     protocols. Recently, Caires, Pfenning, and Toninho, and Wadler, have developed a correspondence
     between propositions of linear logic and session typed &#960;-calculus processes.

     We relate the cut-elimination semantics of this approach to an operational semantics for
     session-typed concurrency in a functional language.

     We begin by presenting a variant of Wadler's session-typed core functional language, GV. We
     give a small-step operational semantics for GV. We develop a suitable notion of deadlock, based
     on existing approaches for capturing deadlock in &#960;-calculus, and show that all well-typed
     GV programs are deadlock-free, deterministic, and terminating.

     We relate GV to linear logic by giving translations between GV and CP, a process calculus with
     a type system and semantics based on classical linear logic.  We prove that both directions of
     our translation preserve reduction; previous translations from GV to CP, in contrast, failed to
     preserve &#946;-reduction.

     Furthermore, to demonstrate the modularity of our approach, we define two extensions of GV
     which preserve deadlock-freedom, determinism, and termination.
   </p>
   <p>
     Available
     from <a href="http://link.springer.com/chapter/10.1007/978-3-662-46669-8_23#">Springer</a> or
     in <a href="pubs/lindley-esop14-propositions.pdf">PDF</a>.
   </p>
 </div>

 <p onclick='toggle("oversem")' class="paper">
   <span id="oversem-closed" class="close">&#9655;</span>
   <span id="oversem-open" class="open">&#9661;</span>
   J. Garrett Morris. "A Simple Semantics of Haskell Overloading". In <i>Proceedings of the 2014
     ACM SIGPLAN Symposium on Haskell</i>, Gothenburg, Sweden.
 </p>

 <div id="oversem">
   <p class="abstract">
     As originally proposed, type classes provide overloading and ad-hoc definition, but can still
     be understood (and implemented) in terms of strictly parametric calculi.  This is not true of
     subsequent extensions of type classes.  Functional dependencies and equality constraints allow
     the satisfiability of predicates to refine typing; this means that the interpretations of
     equivalent qualified types may not be interconvertible.  Overlapping instances and instance
     chains allow predicates to be satisfied without determining the implementations of their
     associated class methods, introducing truly non-parametric behavior.  We propose a new approach
     to the semantics of type classes, interpreting polymorphic expressions by the behavior of each
     of their ground instances, but without requiring that those behaviors be parametrically
     determined.  We argue that this approach both matches the intuitive meanings of qualified types
     and accurately models the behavior of programs.
   </p>
   <p>
     Available from the <a href="http://dl.acm.org/citation.cfm?id=2633364">ACM DL</a> or
     in <a href="pubs/morris-haskell14-oversem.pdf">PDF</a>.
   </p>
 </div>

 <p onclick='toggle("cpgv")' class="paper">
   <span id="cpgv-closed" class="close">&#9655;</span>
   <span id="cpgv-open" class="open">&#9661;</span>
   Sam Lindley and J. Garrett Morris. "Sessions as Propositions". In PLACES
     2014.
 </p>

 <div id="cpgv">
   <p class="abstract">
     Recently, Wadler presented a continuation-passing translation from a session-typed functional
     language, GV, to a process calculus based on classical linear logic, CP. However, this
     translation is one-way: CP is more expressive than GV. We propose an extension of GV, called
     HGV, and give translations showing that it is as expressive as CP. The new translations shed
     light both on the original translation from GV to CP, and on the limitations in expressiveness
     of GV.
   </p>
   <p>
     Available from <a href="http://arxiv.org/abs/1406.3479">arXiv</a> or in
     <a href="pubs/morris-places14-cpgv.pdf">PDF</a>.
   </p>
 </div>

 <p onclick='toggle("thesis")' class="paper">
   <span id="thesis-closed" class="close">&#9655;</span>
   <span id="thesis-open" class="open">&#9661;</span>
   J. Garrett Morris. <i>Type Classes and Instance Chains: A Relational Approach.</i> PhD thesis,
   Portland State University, 2013.
 </p>

 <div id="thesis">
   <p class="abstract">
     Type classes, first proposed during the design of the Haskell programming language, extend
     standard type systems to support overloaded functions. Since their introduction, type classes
     have been used to address a range of problems, from typing ordering and arithmetic operators to
     describing heterogeneous lists and limited subtyping. However, while type class programming is
     useful for a variety of practical problems, its wider use is limited by the inexpressiveness
     and hidden complexity of current mechanisms. We propose two improvements to existing class
     systems. First, we introduce several novel language features, instance chains and explicit
     failure, that increase the expressiveness of type classes while providing more direct
     expression of current idioms. To validate these features, we have built an implementation of
     these features, demonstrating their use in a practical setting and their integration with type
     reconstruction for a Hindley-Milner type system.  Second, we define a set-based semantics for
     type classes that provides a sound basis for reasoning about type class systems, their
     implementations, and the meanings of programs that use them.
   </p>

   <p>Available in <a href="pubs/morris-dissertation.pdf">PDF</a>.</p>
 </div>


 <p onclick='toggle("instances")' class="paper">
   <span id="instances-closed" class="close">&#9655;</span>
   <span id="instances-open" class="open">&#9661;</span>
   J. Garrett Morris and Mark P. Jones.  "Instance Chains: Type Class Programming Without Overlapping Instances."
    In <i>Proceedings of the 15th ACM SIGPLAN International Conference on Functional
    Programming (ICFP '10)</i>, Baltimore, Maryland.
    2010.
 </p>

 <div id="instances">
   <p class="abstract">
     Type classes have found a wide variety of uses in Haskell programs, from simple overloading of
     operators (such as equality or ordering) to complex invariants used to implement type-safe
     heterogeneous lists or limited subtyping.  Unfortunately, many of the richer uses of type
     classes require extensions to the class system that have been incompletely described in the
     research literature and are not universally accepted within the Haskell community.
   </p>

   <p class="abstract">
     This paper describes a new type class system, implemented in a prototype tool
     called <tt>ilab</tt>, that simplifies and enhances Haskell-style type-class programming.
     In <tt>ilab</tt>, we replace overlapping instances with a new feature, <i>instance chains</i>,
     allowing explicit alternation and failure in instance declarations.  We describe a technique
     for ascribing semantics to type class systems, relating classes, instances, and class
     constraints (such as kind signatures or functional dependencies) directly to a set-theoretic
     model of relations on types.  Finally, we give a semantics for <tt>ilab</tt> and describe its
     implementation.
   </p>
   <p>
     Available from the <a href="http://dl.acm.org/citation.cfm?id=1863543.1863596">ACM DL</a> or
     in <a href="pubs/morris-icfp2010-instances.pdf">PDF</a>.
   </p>
 </div>

 <p onclick='toggle("hackage")' class="paper">
   <span id="hackage-closed" class="close">&#9655;</span>
   <span id="hackage-open" class="open">&#9661;</span>
   J. Garrett Morris. "Experience Report: Using Hackage to Inform Language Design."
     In <i>Proceedings of the 3rd ACM Symposium on Haskell (Haskell '10)</i>,
     Baltimore, Maryland.
 </p>

 <div id="hackage">
   <p class="abstract">
     Hackage, an online repository of Haskell applications and libraries, provides a hub for
     programmers to both release code to and use code from the larger Haskell community.  We suggest
     that Hackage can also serve as a valuable resource for language designers: by providing a large
     collection of code written by different programmers and in different styles, it allows language
     designers to see not just how features could be used theoretically, but how they are (and are
     not) used in practice.
   </p>

   <p class="abstract">
     We were able to make such a use of Hackage during the design of the class system for a new
     Haskell-like programming language.  In this paper, we sketch our language design problem, and
     how we used Hackage to help answer it.  We describe our methodology in some detail, including
     both ways that it was and was not effective, and summarize our results.
   </p>
   <p>
     Available from the <a href="http://dl.acm.org/citation.cfm?id=1863523.1863531">ACM DL</a> or
     in <a href="pubs/morris-hw2010-hackage.pdf">PDF</a>.
   </p>
 </div>

 <p><small>Some of these papers are copyright ACM.  These are the author's versions of the work.
     They are posted here by permission of ACM for your personal use.  Not for redistribution.
     Please see each paper for the location of the definitive version.</small></p>
</div>

<div class="box" id="contact">
  <h2>contact information</h2>

  <table>
    <tr>
      <td><strong>email</strong></td>
      <td colspan="2">
        <a href="mailto:garrettm@ku.edu">garrettm@ku.edu</a> (general) <br>
        <a href="mailto:garrett@ittc.ku.edu">garrett@ittc.ku.edu</a> (research-related)
      </td>
    </tr>
    <tr>
      <td><strong>postal mail</strong></td>
      <td>
        2028 Eaton Hall <br>
        1520 W 15th St <br>
        Lawrence, KS 66045 <br>
      </td>
      <td>
        253 Nichols Hall <br>
        2335 Irving Hill Rd <br>
        Lawrence, KS 66045<br>
      </td>
    </tr>
    <tr>
      <td><strong>telephone</strong></td>
      <td>
        (785) 864-8825
      </td>
      <td>
        (785) 864-7968
      </td>
    </tr>
  </table>
</div>


</body>
</html>
